import { TransactionContext } from '../common/TransactionContext';
import { mapPgError } from '../errors/mapPgError';
import {
  ConcurrentModificationError
} from '../errors/persistenceError';
import { Logger } from '../../domain/common/logging';

export class JdbcWorkItemRepository {

  constructor(
    private readonly logger: Logger
  ) {}

  /**
   * Insert a new WorkItem.
   * ID is generated by DB.
   */
  async insert(
    tx: TransactionContext,
    row: {
      workflowId: string;
      state: string;
      taskType?: string | undefined;
      taskName?: string | undefined;
      runId: string;
      context?: unknown;
      parameters?: unknown;
      priority?: number | undefined;
      offeredTo?: string[] | undefined;
      dueDate?: Date | null | undefined;
    }
  ): Promise<number> {

    this.logger.debug('DB insert work_item', {
      workflowId: row.workflowId,
      state: row.state,
      runId: row.runId
    });

    try {
      const result = await tx.query<{ id: number }>(
        `
        INSERT INTO work_items
          (workflow_id, state, task_type, task_name,priority, offered_to, run_id,due_date, context, parameters)
        VALUES
          ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING id
        `,
        [
          row.workflowId,
          row.state,
          row.taskType ?? null,
          row.taskName ?? null,
          row.priority ?? 300,
          JSON.stringify(row.offeredTo ?? []),
          row.runId,
          row.dueDate ?? null,
          
          JSON.stringify(row.context ?? {}),
          JSON.stringify(row.parameters ?? {})
          
        ]
      );

      const created = result.rows[0];
      if (!created) {
        throw new Error('INSERT returned no id');
      }

      this.logger.info('WorkItem created', { id: created.id });
      return created.id;

    } catch (e: unknown) {
      this.logger.error('Failed to insert work_item', e);
      mapPgError(e);
    }
  }

  /**
   * Transition state with optimistic locking.
   */
  async transitionState(
    tx: TransactionContext,
    params: {
      id: number;
      expectedVersion: number;
      toState: string;
      actorId?: string;
    }
  ): Promise<void> {

    this.logger.debug('DB transition work_item', params);

    try {
      const result = await tx.query(
        `
        UPDATE work_items
        SET state = $1,
            version = version + 1,
            updated_at = now(),
            assignee_id = COALESCE($2, assignee_id)
        WHERE id = $3
          AND version = $4
        `,
        [
          params.toState,
          params.actorId ?? null,
          params.id,
          params.expectedVersion
        ]
      );

      if (result.rowCount !== 1) {
        throw new ConcurrentModificationError(
          `Optimistic lock failed for work_item ${params.id}`
        );
      }

      this.logger.info('WorkItem transitioned', {
        id: params.id,
        toState: params.toState
      });

    } catch (e: unknown) {
      this.logger.error('Failed to transition work_item', e);
      mapPgError(e);
    }
  }
}
